{"ast":null,"code":"import { AnimationClip, AnimationMixer, Euler, Matrix4, Quaternion, QuaternionKeyframeTrack, SkeletonHelper, Vector2, Vector3, VectorKeyframeTrack } from '../../../build/three.module.js';\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };","map":{"version":3,"sources":["/Users/kollusaimanaswi/Desktop/intel_avatars/facial-animation/node_modules/three/examples/jsm/utils/SkeletonUtils.js"],"names":["AnimationClip","AnimationMixer","Euler","Matrix4","Quaternion","QuaternionKeyframeTrack","SkeletonHelper","Vector2","Vector3","VectorKeyframeTrack","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"mappings":"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","sourcesContent":["import {\n\tAnimationClip,\n\tAnimationMixer,\n\tEuler,\n\tMatrix4,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tSkeletonHelper,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack\n} from '../../../build/three.module.js';\n\nvar SkeletonUtils = {\n\n\tretarget: function () {\n\n\t\tvar pos = new Vector3(),\n\t\t\tquat = new Quaternion(),\n\t\t\tscale = new Vector3(),\n\t\t\tbindBoneMatrix = new Matrix4(),\n\t\t\trelativeMatrix = new Matrix4(),\n\t\t\tglobalMatrix = new Matrix4();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\t\t\toptions.names = options.names || {};\n\n\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\tbindBones,\n\t\t\t\tbone, name, boneTo,\n\t\t\t\tbonesPosition, i;\n\n\t\t\t// reset bones\n\n\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\ttarget.skeleton.pose();\n\n\t\t\t} else {\n\n\t\t\t\toptions.useTargetMatrix = true;\n\t\t\t\toptions.preserveMatrix = false;\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tbonesPosition = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// reset matrix\n\n\t\t\t\ttarget.updateMatrixWorld();\n\n\t\t\t\ttarget.matrixWorld.identity();\n\n\t\t\t\t// reset children matrix\n\n\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\n\n\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.offsets ) {\n\n\t\t\t\tbindBones = [];\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\n\n\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\n\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ignore scale to extract rotation\n\n\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t\t\t// apply to global matrix\n\n\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\n\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();\n\n\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t// restore matrix\n\n\t\t\t\ttarget.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t};\n\n\t}(),\n\n\tretargetClip: function ( target, source, clip, options ) {\n\n\t\toptions = options || {};\n\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\t\toptions.names = options.names || [];\n\n\t\tif ( ! source.isObject3D ) {\n\n\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t}\n\n\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\t\tdelta = 1 / options.fps,\n\t\t\tconvertedTracks = [],\n\t\t\tmixer = new AnimationMixer( source ),\n\t\t\tbones = this.getBones( target.skeleton ),\n\t\t\tboneDatas = [],\n\t\t\tpositionOffset,\n\t\t\tbone, boneTo, boneData,\n\t\t\tname, i, j;\n\n\t\tmixer.clipAction( clip ).play();\n\t\tmixer.update( 0 );\n\n\t\tsource.updateMatrixWorld();\n\n\t\tfor ( i = 0; i < numFrames; ++ i ) {\n\n\t\t\tvar time = i * delta;\n\n\t\t\tthis.retarget( target, source, options );\n\n\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\n\n\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, source.skeleton );\n\n\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\tbone = bones[ j ];\n\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmixer.update( delta );\n\n\t\t\tsource.updateMatrixWorld();\n\n\t\t}\n\n\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\n\n\t\t\tboneData = boneDatas[ i ];\n\n\t\t\tif ( boneData ) {\n\n\t\t\t\tif ( boneData.pos ) {\n\n\t\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\n\t\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\n\t\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\t\tboneData.pos.values\n\t\t\t\t\t) );\n\n\t\t\t\t}\n\n\t\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\n\t\t\t\t\tboneData.quat.times,\n\t\t\t\t\tboneData.quat.values\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tmixer.uncacheAction( clip );\n\n\t\treturn new AnimationClip( clip.name, - 1, convertedTracks );\n\n\t},\n\n\tgetHelperFromSkeleton: function ( skeleton ) {\n\n\t\tvar source = new SkeletonHelper( skeleton.bones[ 0 ] );\n\t\tsource.skeleton = skeleton;\n\n\t\treturn source;\n\n\t},\n\n\tgetSkeletonOffsets: function () {\n\n\t\tvar targetParentPos = new Vector3(),\n\t\t\ttargetPos = new Vector3(),\n\t\t\tsourceParentPos = new Vector3(),\n\t\t\tsourcePos = new Vector3(),\n\t\t\ttargetDir = new Vector2(),\n\t\t\tsourceDir = new Vector2();\n\n\t\treturn function ( target, source, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\n\t\t\toptions.names = options.names || {};\n\n\t\t\tif ( ! source.isObject3D ) {\n\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t\t}\n\n\t\t\tvar nameKeys = Object.keys( options.names ),\n\t\t\t\tnameValues = Object.values( options.names ),\n\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\toffsets = [],\n\t\t\t\tbone, boneTo,\n\t\t\t\tname, i;\n\n\t\t\ttarget.skeleton.pose();\n\n\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tbone = bones[ i ];\n\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\t\t\tvar boneParent = this.getNearestBone( bone.parent, nameKeys ),\n\t\t\t\t\t\tboneToParent = this.getNearestBone( boneTo.parent, nameValues );\n\n\t\t\t\t\tboneParent.updateMatrixWorld();\n\t\t\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\t\t\ttargetDir.subVectors(\n\t\t\t\t\t\tnew Vector2( targetPos.x, targetPos.y ),\n\t\t\t\t\t\tnew Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tsourceDir.subVectors(\n\t\t\t\t\t\tnew Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\t\t\tnew Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t\t\t).normalize();\n\n\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\t\t\tvar offset = new Matrix4().makeRotationFromEuler(\n\t\t\t\t\t\tnew Euler(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tlaterialAngle\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\tbone.matrix.multiply( offset );\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\toffsets[ name ] = offset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t};\n\n\t}(),\n\n\trenameBones: function ( skeleton, names ) {\n\n\t\tvar bones = this.getBones( skeleton );\n\n\t\tfor ( var i = 0; i < bones.length; ++ i ) {\n\n\t\t\tvar bone = bones[ i ];\n\n\t\t\tif ( names[ bone.name ] ) {\n\n\t\t\t\tbone.name = names[ bone.name ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tgetBones: function ( skeleton ) {\n\n\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n\t},\n\n\tgetBoneByName: function ( name, skeleton ) {\n\n\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\t\tif ( name === bones[ i ].name )\n\n\t\t\t\treturn bones[ i ];\n\n\t\t}\n\n\t},\n\n\tgetNearestBone: function ( bone, names ) {\n\n\t\twhile ( bone.isBone ) {\n\n\t\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t\tbone = bone.parent;\n\n\t\t}\n\n\t},\n\n\tfindBoneTrackData: function ( name, tracks ) {\n\n\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\n\t\t\tresult = { name: name };\n\n\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t// 1 is track name\n\t\t\t// 2 is track type\n\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\n\n\t\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\n\n\t\tvar sourceBones = this.getBones( skeleton ),\n\t\t\ttargetBones = this.getBones( targetSkeleton ),\n\t\t\tbones = [];\n\n\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\n\n\t\t\tvar boneName = sourceBones[ i ].name;\n\n\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\t\tbones.push( boneName );\n\n\t\t\t\t\tcontinue search;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bones;\n\n\t},\n\n\tclone: function ( source ) {\n\n\t\tvar sourceLookup = new Map();\n\t\tvar cloneLookup = new Map();\n\n\t\tvar clone = source.clone();\n\n\t\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t\t} );\n\n\t\tclone.traverse( function ( node ) {\n\n\t\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\t\tvar clonedMesh = node;\n\t\t\tvar sourceMesh = sourceLookup.get( node );\n\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\t\treturn cloneLookup.get( bone );\n\n\t\t\t} );\n\n\t\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t\t} );\n\n\t\treturn clone;\n\n\t}\n\n};\n\n\nfunction parallelTraverse( a, b, callback ) {\n\n\tcallback( a, b );\n\n\tfor ( var i = 0; i < a.children.length; i ++ ) {\n\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t}\n\n}\n\nexport { SkeletonUtils };\n"]},"metadata":{},"sourceType":"module"}